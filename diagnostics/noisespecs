# usage: python noisespecs.py <filter> <noisetype> <input prefix> <outstem> 
# input file name is <input prefix><filter>_DD_DD_map.fits

import sys
import numpy
import healpy
from astropy.io import fits
from astropy import wcs
from os.path import exists
import matplotlib.pyplot as plt
from scipy import ndimage
from collections import namedtuple
import galsim
import json
import re

bd = 40 # padding size
bd2 = 8

nblock = 48
ncol = 22
nradbins = 162
nstart = 0

#Check input format
if len(sys.argv) < 5:
    print('Missing an argument. Usage format is python noisespecs.py <filter> <input prefix> <outstem>\n')
    exit()

# Determine filter to use
filter = sys.argv[1]; nblockuse = 4 # first 4

if filter=='Y': 
  filtername='Y106'
  area= 5915 #cm^2
if filter=='J': 
  filtername='J129'
  area= 6051
if filter=='H': 
  filtername='H158'
  area= 5978
if filter=='F': 
  filtername='F184'
  area= 3929

# Determine type of noise to use (white or 1/f)
if sys.argv[2] == 'white' or sys.argv[2] == 'w' or sys.argv[2] == 'White' or sys.argv[2] == 'W':
    noisetype = 'WN'
elif sys.argv[2] == 'f' or sys.argv[2] == '1f' or sys.argv[2] == 'F' or sys.argv[2] == '1F':
    noisetype = 'FN'

pos = numpy.zeros((1,ncol))
image = numpy.zeros((1,bd*2-1,bd*2-1))

# prefix and suffix
in1 = sys.argv[3]
outstem = sys.argv[4]

#Set useful constants
tfr = 3.08 #sec
gain = 1.458 #electrons/DN
ABstd = 3.631*10**(-20) #erg/cm^2
h = 6.626*10**(-27) #erg/Hz
m_ab = 23.9 #sample mag for PS
s_in = 0.11 #input pixel scale

#Want to save plots? T/F
plot = True

#Loop through all the blocks
for iblock in range(nstart,nstart+nblockuse):

  j = iblock
  ibx = j%nblock; iby = j//nblock

  #Combine in1 with block ID to get input file and block label
  label = '{:s}_{:02d}_{:02d}'.format(filter,ibx,iby)
  infile = in1 + label + '_' + noisetype + '_map.fits'

############################################
 # extract information from the header of the first file
  if iblock==nstart:
    with fits.open(infile) as f:

      n = numpy.shape(f[0].data)[-1] # size of output images

      config = ''
      for g in f['CONFIG'].data['text'].tolist(): config += g+' '
      configStruct = json.loads(config)

      blocksize = int(configStruct['OUTSIZE'][0]) * int(configStruct['OUTSIZE'][1]) * float(configStruct['OUTSIZE'][2]) / 3600. *numpy.pi/180 # radians

      outscale = float(configStruct['OUTSIZE'][2]) # in arcsec
      force_scale = .40/outscale # in output pixels

      # padding region around the edge
      bdpad = int(configStruct['OUTSIZE'][1]) * int(configStruct['PAD'])

      # figure out which layer we want
      layers = [''] + configStruct['EXTRAINPUT']
      print('#', layers)
      for i in range(len(layers))[::-1]:
        if noisetype = 'WN':
            m = re.match(r'^whitenoise(\d+)$', layers[i])
            if m:
              use_slice = i
        elif noisetype = 'FN':
            m = re.match(r'^1fnoise(\d+)$', layers[i])
            if m:
              use_slice = i
      print('# Analyzing ', noisetype, ' using layer', use_slice, ', output pix =', outscale, ', arcsec   n=',n)

  print('# Running file: ' + infile +'\n')

  if not exists(infile): continue
  f = fits.open(infile)
  indata = np.copy(f[0].data[0]).astype(np.float32)
  mean_coverage = np.mean(np.sum(np.where(f['INWEIGHT'].data[0, :, :, :] > 0, 1, 0), axis=0)[2:-2, 2:-2])
  f.close()
  
  norm = tfr/gain * ABstd/h * configInfo.AREA * 10**(-0.4*m_ab) * s_out**2
  
  def measure_power_spectrum(noiseframe, bin):
      """
      Measure the 2D power spectrum of image.
      :param noiseframe: 2D ndarray
       the input image to measure the power spectrum of.
       in this case, a noise frame from the simulations
      :return: 2D ndarray, ps
       the 2D power spectrum of the image.
      """
      noiseframe = noiseframe/norm
      fft = np.fft.fftshift(np.fft.fft2(noiseframe))
      ps = ((np.abs(fft)) ** 2) / ((2600 * 4.4) ** 2)
      if bin == True:
          binned_ps = np.average(np.reshape(ps, (325, 8, 325, 8)), axis = (1,3))
          return binned_ps
      else:
          return ps
  
  
  def _get_wavenumbers(window_length, num_radial_bins=nradbins):
      """
      Calculate wavenumbers for the input image.
      :param window_length: integer
       the length of one axis of the image.
      :param num_radial_bins: integer
       number of radial bins the image should be averaged into
      :return: 1D np array, kmean
       the wavenumbers for the image
      """
      k = np.fft.fftshift(np.fft.fftfreq(window_length))
      kx, ky = np.meshgrid(k, k)
      k = np.sqrt(kx ** 2 + ky ** 2)
      k, kmean, kerr = azimuthal_average(k, num_radial_bins)
  
      # print('k shape: ', k.shape)
  
      return kmean
  
  
  def azimuthal_average(image, num_radial_bins=nradbins):
      """
      Compute radial profile of image.
  
      Parameters
      ----------
      image : 2D ndarray
          Input image.
      num_radial_bins : int
          Number of radial bins in profile.
  
      Returns
      -------
      r : ndarray
          Value of radius at each point
      radial_mean : ndarray
          Mean intensity within each annulus. Main result
      radial_err : ndarray
          Standard error on the mean: sigma / sqrt(N).
      """
  
      ny, nx = image.shape
      yy, xx = np.mgrid[:ny, :nx]
      center = np.array(image.shape) / 2
  
      r = np.hypot(xx - center[1], yy - center[0])
      rbin = (num_radial_bins * r / r.max()).astype(np.int)
  
      radial_mean = ndimage.mean(
          image, labels=rbin, index=np.arange(1, rbin.max() + 1))
  
      radial_stddev = ndimage.standard_deviation(
          image, labels=rbin, index=np.arange(1, rbin.max() + 1))
  
      npix = ndimage.sum(np.ones_like(image), labels=rbin,
                         index=np.arange(1, rbin.max() + 1))
  
      radial_err = radial_stddev / np.sqrt(npix)
      return r, radial_mean, radial_err
  
  def plot_results(result, save_fn, subplots=None, xlabel='Wave number',
                  ylabel='Power', xscale='linear', percentiles=[0.1, 99.9],
                  yscale='log', plot_errors=False,
                  cmap='plasma'):
      '''
      Plot the results of our power spectrum analysis, Plots a 2D and 1D power spectrum
      :param result: 1D ndarray
          the returned result of measure_oned_pspec
      '''
  
      if subplots is None:
          fig, ax = plt.subplots(1, 2, figsize=(15, 5))
          fig.subplots_adjust(wspace=0.2)
      else:
          fig, ax = subplots
  
      vmin, vmax = np.nanpercentile(result.pspec_2d, percentiles)
  
      ax[0].imshow(result.pspec_2d, origin='lower', cmap=cmap,
                   vmin=vmin, vmax=vmax)
  
  
  
      if plot_errors:
          ax[1].errorbar(result.k, result.ps_image,
                         yerr=result.ps_image_err,
                         fmt='k.', lw=2, capsize=3, capthick=1.5, zorder=10)  # Measured power spectrum - points with errorbars
      else:
          ax[1].plot(result.k, result.ps_image, 'k-', lw=1)              # Measured power spectrum - line
  
  
      ax[1].set_xscale(xscale)
      ax[1].set_yscale(yscale)
      ax[1].set_xlabel(xlabel, fontsize=15)
      ax[1].set_ylabel(ylabel, fontsize=15)
      ax[0].set_xlabel('Power (px)',fontsize=15)
      ax[0].set_ylabel('Power (px)',fontsize=15)
      ax[1].tick_params(labelsize=20)
      ax[1].minorticks_on()
      if save_fn is not None:
          fig.savefig(outstem+label+save_fn, bbox_inches='tight', dpi=500)
  
      return fig, ax
  
  
  PspecResults = namedtuple(
      'PspecResults', 'ps_image ps_image_err npix k pspec_2d'
  )
  
  
  def get_powerspectra(noiseframe, num_radial_bins=nradbins):
      """
      Calculate the azimuthally-averaged 1D power spectrum of the image
      :param noiseframe: 2D ndarray
          the input image to be averaged over
      :param num_radial_bins: number of bins, should match bin number in get_wavenumbers
  
      :return: named tuple, results
      """
  
      noise = noiseframe.copy()
  
      ps_image = measure_power_spectrum(noise, bin=True)
      ps_2d = np.copy(ps_image)
  
      ps_r, ps_image, ps_image_err = azimuthal_average(ps_image, num_radial_bins)
  
      wavenumbers = _get_wavenumbers(noise.shape[0], num_radial_bins)
  
      npix = np.product(noiseframe.shape)
  
      # consolidate results
      results = PspecResults(ps_image=ps_image,
                             ps_image_err=ps_image_err,
                             npix=npix,
                             k=wavenumbers,
                             ps_2d = ps_2d
                             )
  
      return results
  
  print('Calculating noise power spectrum...\n')
  powerspectrum = get_powerspectra(indata[7,:,:]) #KL: Make sure 7 is right OR calc/read this
  ps_data = np.column_stack((powerspectrum.k, powerspectrum.ps_image))

  #Save power spectra
  np.savetxt(outstem + label + '_noiseps', ps_data)
  if plot =='True':
    plot_results(powerspectrum,'_noiseps')
